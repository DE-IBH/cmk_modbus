#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-

# cmk_modbus - Check_MK plugin to poll data from modbus-enabled modbus_devices
#
# Authors:
#   Mathias Kr√ºger <noreply@ibh.de>
#   Thomas Liske <liske@ibh.de>
#
# Copyright Holder:
#   2016 (C) IBH IT-Service GmbH [http://www.ibh.de/]
#
# License:
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this package; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#

# Chagelog:
#       initial v0.9.1
#

import argparse
import json
import os
import sys
from argparse import Namespace
from struct import pack, unpack
from pymodbus.client.sync import ModbusTcpClient as ModbusClientTCP
from pymodbus.client.sync import ModbusUdpClient as ModbusClientUDP


def outputJSON(device):
    return json.dumps(device, default=lambda o: o.__dict__, sort_keys=True, indent=2)


def main():
    args = getArgs()

    try:
        with open("{2}/{0}.{1}".format(args.dev, 'json', args.templates)) as deviceDefinition:
            data = deviceDefinition.read()
            current_device = json.loads(data, object_hook=lambda d: Namespace(**d))

        def iterate_device():
            for currRegister in current_device.registers:
                ret = client.read_holding_registers(currRegister.address, 2)
                if ret == None:
                    sys.stderr.write("Read failed: "  + currRegister.description + "\n")
                    currRegister.value = float('NaN')
                    continue
                if not ret.function_code < 0x80:
                    sys.stderr.write("Read failed: "  + currRegister.description + "\n")
                    currRegister.value = float('NaN')
                    continue

                binary_data = pack("HH", ret.getRegister(1), ret.getRegister(0))
                currRegister.value = unpack("f", binary_data)[0]

        if args.proto == "tcp":
                with ModbusClientTCP(args.addr, int(args.port)) as client:
                    iterate_device()
        elif args.proto == "udp":
                with ModbusClientUDP(args.addr, int(args.port)) as client:
                    iterate_device()
        else:
                print("Select a valid and supported protocol. See --help")
                sys.exit()

        print('<<<check_mk>>>\nVersion: cmk_modbus/v0.2/'.format(args.dev))
        print('<<<modbus>>>\n{0}'.format(outputJSON(current_device)))

    except OSError as err:
        print("OS error: {0}".format(err))
    except ValueError:
        print("Opps... ValueError.")
    except:
        print("Unexpected error:", sys.exc_info()[0])
        raise


def getArgs():
    parser = argparse.ArgumentParser(description='Simple CMK Modbus-Agent')
    parser.add_argument('-a', '--addr', help='ip address of device', action="store", dest="addr", required=True)
    parser.add_argument('-p', '--port', help='port (default: 502)', action="store", dest="port", default=502)
    parser.add_argument('-t', '--templates', help='templates directory (default: /etc/cmk_modbus/dev.d)', action="store", dest="templates", default="/etc/cmk_modbus/dev.d")
    parser.add_argument('-d', '--dev', help='name of device template', action="store", dest="dev", required=True)
    parser.add_argument('-P', '--proto', help='udp or tcp (default: tcp)', action="store", dest="proto", default="tcp")

    return parser.parse_args()


if __name__ == "__main__":
    main()
